// Generated by go-wayland-scanner
// https://github.com/pdf/go-wayland/cmd/go-wayland-scanner
// XML file : https://github.com/hyprwm/hyprland-protocols/raw/refs/heads/main/protocols/hyprland-toplevel-export-v1.xml
//
// hyprland_toplevel_export_v1 Protocol Copyright:
//
// Copyright Â© 2022 Vaxry
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
// list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package wl

import "github.com/pdf/go-wayland/client"

// HyprlandToplevelExportManagerV1 : manager to inform clients and begin capturing
//
// This object is a manager which offers requests to start capturing from a
// source.
type HyprlandToplevelExportManagerV1 struct {
	client.BaseProxy
}

// NewHyprlandToplevelExportManagerV1 : manager to inform clients and begin capturing
//
// This object is a manager which offers requests to start capturing from a
// source.
func NewHyprlandToplevelExportManagerV1(ctx *client.Context) *HyprlandToplevelExportManagerV1 {
	hyprlandToplevelExportManagerV1 := &HyprlandToplevelExportManagerV1{}
	ctx.Register(hyprlandToplevelExportManagerV1)
	return hyprlandToplevelExportManagerV1
}

// CaptureToplevel : capture a toplevel
//
// Capture the next frame of a toplevel. (window)
//
// The captured frame will not contain any server-side decorations and will
// ignore the compositor-set geometry, like e.g. rounded corners.
//
// It will contain all the subsurfaces and popups, however the latter will be clipped
// to the geometry of the base surface.
//
// The handle parameter refers to the address of the window as seen in `hyprctl clients`.
// For example, for d161e7b0 it would be 3512854448.
//
//	overlayCursor: composite cursor onto the frame
//	handle: the handle of the toplevel (window) to be captured
func (i *HyprlandToplevelExportManagerV1) CaptureToplevel(overlayCursor int32, handle uint32) (*HyprlandToplevelExportFrameV1, error) {
	frame := NewHyprlandToplevelExportFrameV1(i.Context())
	const opcode = 0
	const _reqBufLen = 8 + 4 + 4 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], frame.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(overlayCursor))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(handle))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return frame, err
}

// Destroy : destroy the manager
//
// All objects created by the manager will still remain valid, until their
// appropriate destroy request has been called.
func (i *HyprlandToplevelExportManagerV1) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 1
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// CaptureToplevelWithWlrToplevelHandle : capture a toplevel
//
// Same as capture_toplevel, but with a zwlr_foreign_toplevel_handle_v1 handle.
//
//	overlayCursor: composite cursor onto the frame
//	handle: the zwlr_foreign_toplevel_handle_v1 handle of the toplevel to be captured
func (i *HyprlandToplevelExportManagerV1) CaptureToplevelWithWlrToplevelHandle(overlayCursor int32, handle *ZwlrForeignToplevelHandleV1) (*HyprlandToplevelExportFrameV1, error) {
	frame := NewHyprlandToplevelExportFrameV1(i.Context())
	const opcode = 2
	const _reqBufLen = 8 + 4 + 4 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], frame.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(overlayCursor))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], handle.ID())
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return frame, err
}

// HyprlandToplevelExportFrameV1 : a frame ready for copy
//
// This object represents a single frame.
//
// When created, a series of buffer events will be sent, each representing a
// supported buffer type. The "buffer_done" event is sent afterwards to
// indicate that all supported buffer types have been enumerated. The client
// will then be able to send a "copy" request. If the capture is successful,
// the compositor will send a "flags" followed by a "ready" event.
//
// wl_shm buffers are always supported, ie. the "buffer" event is guaranteed to be sent.
//
// If the capture failed, the "failed" event is sent. This can happen anytime
// before the "ready" event.
//
// Once either a "ready" or a "failed" event is received, the client should
// destroy the frame.
type HyprlandToplevelExportFrameV1 struct {
	client.BaseProxy
	bufferHandler      HyprlandToplevelExportFrameV1BufferHandlerFunc
	damageHandler      HyprlandToplevelExportFrameV1DamageHandlerFunc
	flagsHandler       HyprlandToplevelExportFrameV1FlagsHandlerFunc
	readyHandler       HyprlandToplevelExportFrameV1ReadyHandlerFunc
	failedHandler      HyprlandToplevelExportFrameV1FailedHandlerFunc
	linuxDmabufHandler HyprlandToplevelExportFrameV1LinuxDmabufHandlerFunc
	bufferDoneHandler  HyprlandToplevelExportFrameV1BufferDoneHandlerFunc
}

// NewHyprlandToplevelExportFrameV1 : a frame ready for copy
//
// This object represents a single frame.
//
// When created, a series of buffer events will be sent, each representing a
// supported buffer type. The "buffer_done" event is sent afterwards to
// indicate that all supported buffer types have been enumerated. The client
// will then be able to send a "copy" request. If the capture is successful,
// the compositor will send a "flags" followed by a "ready" event.
//
// wl_shm buffers are always supported, ie. the "buffer" event is guaranteed to be sent.
//
// If the capture failed, the "failed" event is sent. This can happen anytime
// before the "ready" event.
//
// Once either a "ready" or a "failed" event is received, the client should
// destroy the frame.
func NewHyprlandToplevelExportFrameV1(ctx *client.Context) *HyprlandToplevelExportFrameV1 {
	hyprlandToplevelExportFrameV1 := &HyprlandToplevelExportFrameV1{}
	ctx.Register(hyprlandToplevelExportFrameV1)
	return hyprlandToplevelExportFrameV1
}

// Copy : copy the frame
//
// Copy the frame to the supplied buffer. The buffer must have the
// correct size, see hyprland_toplevel_export_frame_v1.buffer and
// hyprland_toplevel_export_frame_v1.linux_dmabuf. The buffer needs to have a
// supported format.
//
// If the frame is successfully copied, a "flags" and a "ready" event is
// sent. Otherwise, a "failed" event is sent.
//
// This event will wait for appropriate damage to be copied, unless the ignore_damage
// arg is set to a non-zero value.
func (i *HyprlandToplevelExportFrameV1) Copy(buffer *client.Buffer, ignoreDamage int32) error {
	const opcode = 0
	const _reqBufLen = 8 + 4 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], buffer.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(ignoreDamage))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// Destroy : delete this object, used or not
//
// Destroys the frame. This request can be sent at any time by the client.
func (i *HyprlandToplevelExportFrameV1) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 1
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

type HyprlandToplevelExportFrameV1Error uint32

// HyprlandToplevelExportFrameV1Error :
const (
	// HyprlandToplevelExportFrameV1ErrorAlreadyUsed : the object has already been used to copy a wl_buffer
	HyprlandToplevelExportFrameV1ErrorAlreadyUsed HyprlandToplevelExportFrameV1Error = 0
	// HyprlandToplevelExportFrameV1ErrorInvalidBuffer : buffer attributes are invalid
	HyprlandToplevelExportFrameV1ErrorInvalidBuffer HyprlandToplevelExportFrameV1Error = 1
)

func (e HyprlandToplevelExportFrameV1Error) Name() string {
	switch e {
	case HyprlandToplevelExportFrameV1ErrorAlreadyUsed:
		return "already_used"
	case HyprlandToplevelExportFrameV1ErrorInvalidBuffer:
		return "invalid_buffer"
	default:
		return ""
	}
}

func (e HyprlandToplevelExportFrameV1Error) Value() string {
	switch e {
	case HyprlandToplevelExportFrameV1ErrorAlreadyUsed:
		return "0"
	case HyprlandToplevelExportFrameV1ErrorInvalidBuffer:
		return "1"
	default:
		return ""
	}
}

func (e HyprlandToplevelExportFrameV1Error) String() string {
	return e.Name() + "=" + e.Value()
}

type HyprlandToplevelExportFrameV1Flags uint32

// HyprlandToplevelExportFrameV1Flags :
const (
	// HyprlandToplevelExportFrameV1FlagsYInvert : contents are y-inverted
	HyprlandToplevelExportFrameV1FlagsYInvert HyprlandToplevelExportFrameV1Flags = 1
)

func (e HyprlandToplevelExportFrameV1Flags) Name() string {
	switch e {
	case HyprlandToplevelExportFrameV1FlagsYInvert:
		return "y_invert"
	default:
		return ""
	}
}

func (e HyprlandToplevelExportFrameV1Flags) Value() string {
	switch e {
	case HyprlandToplevelExportFrameV1FlagsYInvert:
		return "1"
	default:
		return ""
	}
}

func (e HyprlandToplevelExportFrameV1Flags) String() string {
	return e.Name() + "=" + e.Value()
}

// HyprlandToplevelExportFrameV1BufferEvent : wl_shm buffer information
//
// Provides information about wl_shm buffer parameters that need to be
// used for this frame. This event is sent once after the frame is created
// if wl_shm buffers are supported.
type HyprlandToplevelExportFrameV1BufferEvent struct {
	Format uint32
	Width  uint32
	Height uint32
	Stride uint32
}
type HyprlandToplevelExportFrameV1BufferHandlerFunc func(HyprlandToplevelExportFrameV1BufferEvent)

// SetBufferHandler : sets handler for HyprlandToplevelExportFrameV1BufferEvent
func (i *HyprlandToplevelExportFrameV1) SetBufferHandler(f HyprlandToplevelExportFrameV1BufferHandlerFunc) {
	i.bufferHandler = f
}

// HyprlandToplevelExportFrameV1DamageEvent : carries the coordinates of the damaged region
//
// This event is sent right before the ready event when ignore_damage was
// not set. It may be generated multiple times for each copy
// request.
//
// The arguments describe a box around an area that has changed since the
// last copy request that was derived from the current screencopy manager
// instance.
//
// The union of all regions received between the call to copy
// and a ready event is the total damage since the prior ready event.
type HyprlandToplevelExportFrameV1DamageEvent struct {
	X      uint32
	Y      uint32
	Width  uint32
	Height uint32
}
type HyprlandToplevelExportFrameV1DamageHandlerFunc func(HyprlandToplevelExportFrameV1DamageEvent)

// SetDamageHandler : sets handler for HyprlandToplevelExportFrameV1DamageEvent
func (i *HyprlandToplevelExportFrameV1) SetDamageHandler(f HyprlandToplevelExportFrameV1DamageHandlerFunc) {
	i.damageHandler = f
}

// HyprlandToplevelExportFrameV1FlagsEvent : frame flags
//
// Provides flags about the frame. This event is sent once before the
// "ready" event.
type HyprlandToplevelExportFrameV1FlagsEvent struct {
	Flags uint32
}
type HyprlandToplevelExportFrameV1FlagsHandlerFunc func(HyprlandToplevelExportFrameV1FlagsEvent)

// SetFlagsHandler : sets handler for HyprlandToplevelExportFrameV1FlagsEvent
func (i *HyprlandToplevelExportFrameV1) SetFlagsHandler(f HyprlandToplevelExportFrameV1FlagsHandlerFunc) {
	i.flagsHandler = f
}

// HyprlandToplevelExportFrameV1ReadyEvent : indicates frame is available for reading
//
// Called as soon as the frame is copied, indicating it is available
// for reading. This event includes the time at which presentation happened
// at.
//
// The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,
// each component being an unsigned 32-bit value. Whole seconds are in
// tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,
// and the additional fractional part in tv_nsec as nanoseconds. Hence,
// for valid timestamps tv_nsec must be in [0, 999999999]. The seconds part
// may have an arbitrary offset at start.
//
// After receiving this event, the client should destroy the object.
type HyprlandToplevelExportFrameV1ReadyEvent struct {
	TvSecHi uint32
	TvSecLo uint32
	TvNsec  uint32
}
type HyprlandToplevelExportFrameV1ReadyHandlerFunc func(HyprlandToplevelExportFrameV1ReadyEvent)

// SetReadyHandler : sets handler for HyprlandToplevelExportFrameV1ReadyEvent
func (i *HyprlandToplevelExportFrameV1) SetReadyHandler(f HyprlandToplevelExportFrameV1ReadyHandlerFunc) {
	i.readyHandler = f
}

// HyprlandToplevelExportFrameV1FailedEvent : frame copy failed
//
// This event indicates that the attempted frame copy has failed.
//
// After receiving this event, the client should destroy the object.
type HyprlandToplevelExportFrameV1FailedEvent struct{}
type HyprlandToplevelExportFrameV1FailedHandlerFunc func(HyprlandToplevelExportFrameV1FailedEvent)

// SetFailedHandler : sets handler for HyprlandToplevelExportFrameV1FailedEvent
func (i *HyprlandToplevelExportFrameV1) SetFailedHandler(f HyprlandToplevelExportFrameV1FailedHandlerFunc) {
	i.failedHandler = f
}

// HyprlandToplevelExportFrameV1LinuxDmabufEvent : linux-dmabuf buffer information
//
// Provides information about linux-dmabuf buffer parameters that need to
// be used for this frame. This event is sent once after the frame is
// created if linux-dmabuf buffers are supported.
type HyprlandToplevelExportFrameV1LinuxDmabufEvent struct {
	Format uint32
	Width  uint32
	Height uint32
}
type HyprlandToplevelExportFrameV1LinuxDmabufHandlerFunc func(HyprlandToplevelExportFrameV1LinuxDmabufEvent)

// SetLinuxDmabufHandler : sets handler for HyprlandToplevelExportFrameV1LinuxDmabufEvent
func (i *HyprlandToplevelExportFrameV1) SetLinuxDmabufHandler(f HyprlandToplevelExportFrameV1LinuxDmabufHandlerFunc) {
	i.linuxDmabufHandler = f
}

// HyprlandToplevelExportFrameV1BufferDoneEvent : all buffer types reported
//
// This event is sent once after all buffer events have been sent.
//
// The client should proceed to create a buffer of one of the supported
// types, and send a "copy" request.
type HyprlandToplevelExportFrameV1BufferDoneEvent struct{}
type HyprlandToplevelExportFrameV1BufferDoneHandlerFunc func(HyprlandToplevelExportFrameV1BufferDoneEvent)

// SetBufferDoneHandler : sets handler for HyprlandToplevelExportFrameV1BufferDoneEvent
func (i *HyprlandToplevelExportFrameV1) SetBufferDoneHandler(f HyprlandToplevelExportFrameV1BufferDoneHandlerFunc) {
	i.bufferDoneHandler = f
}

func (i *HyprlandToplevelExportFrameV1) Dispatch(opcode uint32, fd int, data []byte) {
	switch opcode {
	case 0:
		if i.bufferHandler == nil {
			return
		}
		var e HyprlandToplevelExportFrameV1BufferEvent
		l := 0
		e.Format = client.Uint32(data[l : l+4])
		l += 4
		e.Width = client.Uint32(data[l : l+4])
		l += 4
		e.Height = client.Uint32(data[l : l+4])
		l += 4
		e.Stride = client.Uint32(data[l : l+4])

		i.bufferHandler(e)
	case 1:
		if i.damageHandler == nil {
			return
		}
		var e HyprlandToplevelExportFrameV1DamageEvent
		l := 0
		e.X = client.Uint32(data[l : l+4])
		l += 4
		e.Y = client.Uint32(data[l : l+4])
		l += 4
		e.Width = client.Uint32(data[l : l+4])
		l += 4
		e.Height = client.Uint32(data[l : l+4])

		i.damageHandler(e)
	case 2:
		if i.flagsHandler == nil {
			return
		}
		var e HyprlandToplevelExportFrameV1FlagsEvent
		l := 0
		e.Flags = client.Uint32(data[l : l+4])

		i.flagsHandler(e)
	case 3:
		if i.readyHandler == nil {
			return
		}
		var e HyprlandToplevelExportFrameV1ReadyEvent
		l := 0
		e.TvSecHi = client.Uint32(data[l : l+4])
		l += 4
		e.TvSecLo = client.Uint32(data[l : l+4])
		l += 4
		e.TvNsec = client.Uint32(data[l : l+4])

		i.readyHandler(e)
	case 4:
		if i.failedHandler == nil {
			return
		}
		var e HyprlandToplevelExportFrameV1FailedEvent

		i.failedHandler(e)
	case 5:
		if i.linuxDmabufHandler == nil {
			return
		}
		var e HyprlandToplevelExportFrameV1LinuxDmabufEvent
		l := 0
		e.Format = client.Uint32(data[l : l+4])
		l += 4
		e.Width = client.Uint32(data[l : l+4])
		l += 4
		e.Height = client.Uint32(data[l : l+4])

		i.linuxDmabufHandler(e)
	case 6:
		if i.bufferDoneHandler == nil {
			return
		}
		var e HyprlandToplevelExportFrameV1BufferDoneEvent

		i.bufferDoneHandler(e)
	}
}
