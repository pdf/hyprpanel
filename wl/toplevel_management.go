// Generated by go-wayland-scanner
// https://github.com/pdf/go-wayland/cmd/go-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wlroots/wlr-protocols/-/raw/master/unstable/wlr-foreign-toplevel-management-unstable-v1.xml
//
// wlr_foreign_toplevel_management_unstable_v1 Protocol Copyright:
//
// Copyright Â© 2018 Ilia Bozhinov
//
// Permission to use, copy, modify, distribute, and sell this
// software and its documentation for any purpose is hereby granted
// without fee, provided that the above copyright notice appear in
// all copies and that both that copyright notice and this permission
// notice appear in supporting documentation, and that the name of
// the copyright holders not be used in advertising or publicity
// pertaining to distribution of the software without specific,
// written prior permission.  The copyright holders make no
// representations about the suitability of this software for any
// purpose.  It is provided "as is" without express or implied
// warranty.
//
// THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
// SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
// SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
// ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
// THIS SOFTWARE.

package wl

import "github.com/pdf/go-wayland/client"

// ZwlrForeignToplevelManagerV1 : list and control opened apps
//
// The purpose of this protocol is to enable the creation of taskbars
// and docks by providing them with a list of opened applications and
// letting them request certain actions on them, like maximizing, etc.
//
// After a client binds the zwlr_foreign_toplevel_manager_v1, each opened
// toplevel window will be sent via the toplevel event
type ZwlrForeignToplevelManagerV1 struct {
	client.BaseProxy
	toplevelHandler ZwlrForeignToplevelManagerV1ToplevelHandlerFunc
	finishedHandler ZwlrForeignToplevelManagerV1FinishedHandlerFunc
}

// NewZwlrForeignToplevelManagerV1 : list and control opened apps
//
// The purpose of this protocol is to enable the creation of taskbars
// and docks by providing them with a list of opened applications and
// letting them request certain actions on them, like maximizing, etc.
//
// After a client binds the zwlr_foreign_toplevel_manager_v1, each opened
// toplevel window will be sent via the toplevel event
func NewZwlrForeignToplevelManagerV1(ctx *client.Context) *ZwlrForeignToplevelManagerV1 {
	zwlrForeignToplevelManagerV1 := &ZwlrForeignToplevelManagerV1{}
	ctx.Register(zwlrForeignToplevelManagerV1)
	return zwlrForeignToplevelManagerV1
}

// Stop : stop sending events
//
// Indicates the client no longer wishes to receive events for new toplevels.
// However the compositor may emit further toplevel_created events, until
// the finished event is emitted.
//
// The client must not send any more requests after this one.
func (i *ZwlrForeignToplevelManagerV1) Stop() error {
	const opcode = 0
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

func (i *ZwlrForeignToplevelManagerV1) Destroy() error {
	i.Context().Unregister(i)
	return nil
}

// ZwlrForeignToplevelManagerV1ToplevelEvent : a toplevel has been created
//
// This event is emitted whenever a new toplevel window is created. It
// is emitted for all toplevels, regardless of the app that has created
// them.
//
// All initial details of the toplevel(title, app_id, states, etc.) will
// be sent immediately after this event via the corresponding events in
// zwlr_foreign_toplevel_handle_v1.
type ZwlrForeignToplevelManagerV1ToplevelEvent struct {
	Toplevel *ZwlrForeignToplevelHandleV1
}
type ZwlrForeignToplevelManagerV1ToplevelHandlerFunc func(ZwlrForeignToplevelManagerV1ToplevelEvent)

// SetToplevelHandler : sets handler for ZwlrForeignToplevelManagerV1ToplevelEvent
func (i *ZwlrForeignToplevelManagerV1) SetToplevelHandler(f ZwlrForeignToplevelManagerV1ToplevelHandlerFunc) {
	i.toplevelHandler = f
}

// ZwlrForeignToplevelManagerV1FinishedEvent : the compositor has finished with the toplevel manager
//
// This event indicates that the compositor is done sending events to the
// zwlr_foreign_toplevel_manager_v1. The server will destroy the object
// immediately after sending this request, so it will become invalid and
// the client should free any resources associated with it.
type ZwlrForeignToplevelManagerV1FinishedEvent struct{}
type ZwlrForeignToplevelManagerV1FinishedHandlerFunc func(ZwlrForeignToplevelManagerV1FinishedEvent)

// SetFinishedHandler : sets handler for ZwlrForeignToplevelManagerV1FinishedEvent
func (i *ZwlrForeignToplevelManagerV1) SetFinishedHandler(f ZwlrForeignToplevelManagerV1FinishedHandlerFunc) {
	i.finishedHandler = f
}

func (i *ZwlrForeignToplevelManagerV1) Dispatch(opcode uint32, fd int, data []byte) {
	switch opcode {
	case 0:
		if i.toplevelHandler == nil {
			return
		}
		var e ZwlrForeignToplevelManagerV1ToplevelEvent
		l := 0
		e.Toplevel = i.Context().GetOrRegister(client.Uint32(data[l:l+4]), (*ZwlrForeignToplevelHandleV1)(nil)).(*ZwlrForeignToplevelHandleV1)

		i.toplevelHandler(e)
	case 1:
		if i.finishedHandler == nil {
			return
		}
		var e ZwlrForeignToplevelManagerV1FinishedEvent

		i.finishedHandler(e)
	}
}

// ZwlrForeignToplevelHandleV1 : an opened toplevel
//
// A zwlr_foreign_toplevel_handle_v1 object represents an opened toplevel
// window. Each app may have multiple opened toplevels.
//
// Each toplevel has a list of outputs it is visible on, conveyed to the
// client with the output_enter and output_leave events.
type ZwlrForeignToplevelHandleV1 struct {
	client.BaseProxy
	titleHandler       ZwlrForeignToplevelHandleV1TitleHandlerFunc
	appIdHandler       ZwlrForeignToplevelHandleV1AppIdHandlerFunc
	outputEnterHandler ZwlrForeignToplevelHandleV1OutputEnterHandlerFunc
	outputLeaveHandler ZwlrForeignToplevelHandleV1OutputLeaveHandlerFunc
	stateHandler       ZwlrForeignToplevelHandleV1StateHandlerFunc
	doneHandler        ZwlrForeignToplevelHandleV1DoneHandlerFunc
	closedHandler      ZwlrForeignToplevelHandleV1ClosedHandlerFunc
	parentHandler      ZwlrForeignToplevelHandleV1ParentHandlerFunc
}

// NewZwlrForeignToplevelHandleV1 : an opened toplevel
//
// A zwlr_foreign_toplevel_handle_v1 object represents an opened toplevel
// window. Each app may have multiple opened toplevels.
//
// Each toplevel has a list of outputs it is visible on, conveyed to the
// client with the output_enter and output_leave events.
func NewZwlrForeignToplevelHandleV1(ctx *client.Context) *ZwlrForeignToplevelHandleV1 {
	zwlrForeignToplevelHandleV1 := &ZwlrForeignToplevelHandleV1{}
	ctx.Register(zwlrForeignToplevelHandleV1)
	return zwlrForeignToplevelHandleV1
}

// SetMaximized : requests that the toplevel be maximized
//
// Requests that the toplevel be maximized. If the maximized state actually
// changes, this will be indicated by the state event.
func (i *ZwlrForeignToplevelHandleV1) SetMaximized() error {
	const opcode = 0
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// UnsetMaximized : requests that the toplevel be unmaximized
//
// Requests that the toplevel be unmaximized. If the maximized state actually
// changes, this will be indicated by the state event.
func (i *ZwlrForeignToplevelHandleV1) UnsetMaximized() error {
	const opcode = 1
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// SetMinimized : requests that the toplevel be minimized
//
// Requests that the toplevel be minimized. If the minimized state actually
// changes, this will be indicated by the state event.
func (i *ZwlrForeignToplevelHandleV1) SetMinimized() error {
	const opcode = 2
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// UnsetMinimized : requests that the toplevel be unminimized
//
// Requests that the toplevel be unminimized. If the minimized state actually
// changes, this will be indicated by the state event.
func (i *ZwlrForeignToplevelHandleV1) UnsetMinimized() error {
	const opcode = 3
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// Activate : activate the toplevel
//
// Request that this toplevel be activated on the given seat.
// There is no guarantee the toplevel will be actually activated.
func (i *ZwlrForeignToplevelHandleV1) Activate(seat *client.Seat) error {
	const opcode = 4
	const _reqBufLen = 8 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], seat.ID())
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// Close : request that the toplevel be closed
//
// Send a request to the toplevel to close itself. The compositor would
// typically use a shell-specific method to carry out this request, for
// example by sending the xdg_toplevel.close event. However, this gives
// no guarantees the toplevel will actually be destroyed. If and when
// this happens, the zwlr_foreign_toplevel_handle_v1.closed event will
// be emitted.
func (i *ZwlrForeignToplevelHandleV1) Close() error {
	const opcode = 5
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// SetRectangle : the rectangle which represents the toplevel
//
// The rectangle of the surface specified in this request corresponds to
// the place where the app using this protocol represents the given toplevel.
// It can be used by the compositor as a hint for some operations, e.g
// minimizing. The client is however not required to set this, in which
// case the compositor is free to decide some default value.
//
// If the client specifies more than one rectangle, only the last one is
// considered.
//
// The dimensions are given in surface-local coordinates.
// Setting width=height=0 removes the already-set rectangle.
func (i *ZwlrForeignToplevelHandleV1) SetRectangle(surface *client.Surface, x, y, width, height int32) error {
	const opcode = 6
	const _reqBufLen = 8 + 4 + 4 + 4 + 4 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], surface.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(x))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(y))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(width))
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(height))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// Destroy : destroy the zwlr_foreign_toplevel_handle_v1 object
//
// Destroys the zwlr_foreign_toplevel_handle_v1 object.
//
// This request should be called either when the client does not want to
// use the toplevel anymore or after the closed event to finalize the
// destruction of the object.
func (i *ZwlrForeignToplevelHandleV1) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 7
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// SetFullscreen : request that the toplevel be fullscreened
//
// Requests that the toplevel be fullscreened on the given output. If the
// fullscreen state and/or the outputs the toplevel is visible on actually
// change, this will be indicated by the state and output_enter/leave
// events.
//
// The output parameter is only a hint to the compositor. Also, if output
// is NULL, the compositor should decide which output the toplevel will be
// fullscreened on, if at all.
func (i *ZwlrForeignToplevelHandleV1) SetFullscreen(output *client.Output) error {
	const opcode = 8
	const _reqBufLen = 8 + 4
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	l += 4
	if output == nil {
		client.PutUint32(_reqBuf[l:l+4], 0)
	} else {
		client.PutUint32(_reqBuf[l:l+4], output.ID())
	}
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

// UnsetFullscreen : request that the toplevel be unfullscreened
//
// Requests that the toplevel be unfullscreened. If the fullscreen state
// actually changes, this will be indicated by the state event.
func (i *ZwlrForeignToplevelHandleV1) UnsetFullscreen() error {
	const opcode = 9
	const _reqBufLen = 8
	var _reqBuf [_reqBufLen]byte
	l := 0
	client.PutUint32(_reqBuf[l:4], i.ID())
	l += 4
	client.PutUint32(_reqBuf[l:l+4], uint32(_reqBufLen<<16|opcode&0x0000ffff))
	err := i.Context().WriteMsg(_reqBuf[:], nil)
	return err
}

type ZwlrForeignToplevelHandleV1State uint32

// ZwlrForeignToplevelHandleV1State : types of states on the toplevel
//
// The different states that a toplevel can have. These have the same meaning
// as the states with the same names defined in xdg-toplevel
const (
	// ZwlrForeignToplevelHandleV1StateMaximized : the toplevel is maximized
	ZwlrForeignToplevelHandleV1StateMaximized ZwlrForeignToplevelHandleV1State = 0
	// ZwlrForeignToplevelHandleV1StateMinimized : the toplevel is minimized
	ZwlrForeignToplevelHandleV1StateMinimized ZwlrForeignToplevelHandleV1State = 1
	// ZwlrForeignToplevelHandleV1StateActivated : the toplevel is active
	ZwlrForeignToplevelHandleV1StateActivated ZwlrForeignToplevelHandleV1State = 2
	// ZwlrForeignToplevelHandleV1StateFullscreen : the toplevel is fullscreen
	ZwlrForeignToplevelHandleV1StateFullscreen ZwlrForeignToplevelHandleV1State = 3
)

func (e ZwlrForeignToplevelHandleV1State) Name() string {
	switch e {
	case ZwlrForeignToplevelHandleV1StateMaximized:
		return "maximized"
	case ZwlrForeignToplevelHandleV1StateMinimized:
		return "minimized"
	case ZwlrForeignToplevelHandleV1StateActivated:
		return "activated"
	case ZwlrForeignToplevelHandleV1StateFullscreen:
		return "fullscreen"
	default:
		return ""
	}
}

func (e ZwlrForeignToplevelHandleV1State) Value() string {
	switch e {
	case ZwlrForeignToplevelHandleV1StateMaximized:
		return "0"
	case ZwlrForeignToplevelHandleV1StateMinimized:
		return "1"
	case ZwlrForeignToplevelHandleV1StateActivated:
		return "2"
	case ZwlrForeignToplevelHandleV1StateFullscreen:
		return "3"
	default:
		return ""
	}
}

func (e ZwlrForeignToplevelHandleV1State) String() string {
	return e.Name() + "=" + e.Value()
}

type ZwlrForeignToplevelHandleV1Error uint32

// ZwlrForeignToplevelHandleV1Error :
const (
	// ZwlrForeignToplevelHandleV1ErrorInvalidRectangle : the provided rectangle is invalid
	ZwlrForeignToplevelHandleV1ErrorInvalidRectangle ZwlrForeignToplevelHandleV1Error = 0
)

func (e ZwlrForeignToplevelHandleV1Error) Name() string {
	switch e {
	case ZwlrForeignToplevelHandleV1ErrorInvalidRectangle:
		return "invalid_rectangle"
	default:
		return ""
	}
}

func (e ZwlrForeignToplevelHandleV1Error) Value() string {
	switch e {
	case ZwlrForeignToplevelHandleV1ErrorInvalidRectangle:
		return "0"
	default:
		return ""
	}
}

func (e ZwlrForeignToplevelHandleV1Error) String() string {
	return e.Name() + "=" + e.Value()
}

// ZwlrForeignToplevelHandleV1TitleEvent : title change
//
// This event is emitted whenever the title of the toplevel changes.
type ZwlrForeignToplevelHandleV1TitleEvent struct {
	Title string
}
type ZwlrForeignToplevelHandleV1TitleHandlerFunc func(ZwlrForeignToplevelHandleV1TitleEvent)

// SetTitleHandler : sets handler for ZwlrForeignToplevelHandleV1TitleEvent
func (i *ZwlrForeignToplevelHandleV1) SetTitleHandler(f ZwlrForeignToplevelHandleV1TitleHandlerFunc) {
	i.titleHandler = f
}

// ZwlrForeignToplevelHandleV1AppIdEvent : app-id change
//
// This event is emitted whenever the app-id of the toplevel changes.
type ZwlrForeignToplevelHandleV1AppIdEvent struct {
	AppId string
}
type ZwlrForeignToplevelHandleV1AppIdHandlerFunc func(ZwlrForeignToplevelHandleV1AppIdEvent)

// SetAppIdHandler : sets handler for ZwlrForeignToplevelHandleV1AppIdEvent
func (i *ZwlrForeignToplevelHandleV1) SetAppIdHandler(f ZwlrForeignToplevelHandleV1AppIdHandlerFunc) {
	i.appIdHandler = f
}

// ZwlrForeignToplevelHandleV1OutputEnterEvent : toplevel entered an output
//
// This event is emitted whenever the toplevel becomes visible on
// the given output. A toplevel may be visible on multiple outputs.
type ZwlrForeignToplevelHandleV1OutputEnterEvent struct {
	Output *client.Output
}
type ZwlrForeignToplevelHandleV1OutputEnterHandlerFunc func(ZwlrForeignToplevelHandleV1OutputEnterEvent)

// SetOutputEnterHandler : sets handler for ZwlrForeignToplevelHandleV1OutputEnterEvent
func (i *ZwlrForeignToplevelHandleV1) SetOutputEnterHandler(f ZwlrForeignToplevelHandleV1OutputEnterHandlerFunc) {
	i.outputEnterHandler = f
}

// ZwlrForeignToplevelHandleV1OutputLeaveEvent : toplevel left an output
//
// This event is emitted whenever the toplevel stops being visible on
// the given output. It is guaranteed that an entered-output event
// with the same output has been emitted before this event.
type ZwlrForeignToplevelHandleV1OutputLeaveEvent struct {
	Output *client.Output
}
type ZwlrForeignToplevelHandleV1OutputLeaveHandlerFunc func(ZwlrForeignToplevelHandleV1OutputLeaveEvent)

// SetOutputLeaveHandler : sets handler for ZwlrForeignToplevelHandleV1OutputLeaveEvent
func (i *ZwlrForeignToplevelHandleV1) SetOutputLeaveHandler(f ZwlrForeignToplevelHandleV1OutputLeaveHandlerFunc) {
	i.outputLeaveHandler = f
}

// ZwlrForeignToplevelHandleV1StateEvent : the toplevel state changed
//
// This event is emitted immediately after the zlw_foreign_toplevel_handle_v1
// is created and each time the toplevel state changes, either because of a
// compositor action or because of a request in this protocol.
type ZwlrForeignToplevelHandleV1StateEvent struct {
	State []byte
}
type ZwlrForeignToplevelHandleV1StateHandlerFunc func(ZwlrForeignToplevelHandleV1StateEvent)

// SetStateHandler : sets handler for ZwlrForeignToplevelHandleV1StateEvent
func (i *ZwlrForeignToplevelHandleV1) SetStateHandler(f ZwlrForeignToplevelHandleV1StateHandlerFunc) {
	i.stateHandler = f
}

// ZwlrForeignToplevelHandleV1DoneEvent : all information about the toplevel has been sent
//
// This event is sent after all changes in the toplevel state have been
// sent.
//
// This allows changes to the zwlr_foreign_toplevel_handle_v1 properties
// to be seen as atomic, even if they happen via multiple events.
type ZwlrForeignToplevelHandleV1DoneEvent struct{}
type ZwlrForeignToplevelHandleV1DoneHandlerFunc func(ZwlrForeignToplevelHandleV1DoneEvent)

// SetDoneHandler : sets handler for ZwlrForeignToplevelHandleV1DoneEvent
func (i *ZwlrForeignToplevelHandleV1) SetDoneHandler(f ZwlrForeignToplevelHandleV1DoneHandlerFunc) {
	i.doneHandler = f
}

// ZwlrForeignToplevelHandleV1ClosedEvent : this toplevel has been destroyed
//
// This event means the toplevel has been destroyed. It is guaranteed there
// won't be any more events for this zwlr_foreign_toplevel_handle_v1. The
// toplevel itself becomes inert so any requests will be ignored except the
// destroy request.
type ZwlrForeignToplevelHandleV1ClosedEvent struct{}
type ZwlrForeignToplevelHandleV1ClosedHandlerFunc func(ZwlrForeignToplevelHandleV1ClosedEvent)

// SetClosedHandler : sets handler for ZwlrForeignToplevelHandleV1ClosedEvent
func (i *ZwlrForeignToplevelHandleV1) SetClosedHandler(f ZwlrForeignToplevelHandleV1ClosedHandlerFunc) {
	i.closedHandler = f
}

// ZwlrForeignToplevelHandleV1ParentEvent : parent change
//
// This event is emitted whenever the parent of the toplevel changes.
//
// No event is emitted when the parent handle is destroyed by the client.
type ZwlrForeignToplevelHandleV1ParentEvent struct {
	Parent *ZwlrForeignToplevelHandleV1
}
type ZwlrForeignToplevelHandleV1ParentHandlerFunc func(ZwlrForeignToplevelHandleV1ParentEvent)

// SetParentHandler : sets handler for ZwlrForeignToplevelHandleV1ParentEvent
func (i *ZwlrForeignToplevelHandleV1) SetParentHandler(f ZwlrForeignToplevelHandleV1ParentHandlerFunc) {
	i.parentHandler = f
}

func (i *ZwlrForeignToplevelHandleV1) Dispatch(opcode uint32, fd int, data []byte) {
	switch opcode {
	case 0:
		if i.titleHandler == nil {
			return
		}
		var e ZwlrForeignToplevelHandleV1TitleEvent
		l := 0
		titleLen := client.PaddedLen(int(client.Uint32(data[l : l+4])))
		l += 4
		e.Title = client.String(data[l : l+titleLen])

		i.titleHandler(e)
	case 1:
		if i.appIdHandler == nil {
			return
		}
		var e ZwlrForeignToplevelHandleV1AppIdEvent
		l := 0
		appIdLen := client.PaddedLen(int(client.Uint32(data[l : l+4])))
		l += 4
		e.AppId = client.String(data[l : l+appIdLen])

		i.appIdHandler(e)
	case 2:
		if i.outputEnterHandler == nil {
			return
		}
		var e ZwlrForeignToplevelHandleV1OutputEnterEvent
		l := 0
		e.Output = i.Context().GetOrRegister(client.Uint32(data[l:l+4]), (*client.Output)(nil)).(*client.Output)

		i.outputEnterHandler(e)
	case 3:
		if i.outputLeaveHandler == nil {
			return
		}
		var e ZwlrForeignToplevelHandleV1OutputLeaveEvent
		l := 0
		e.Output = i.Context().GetOrRegister(client.Uint32(data[l:l+4]), (*client.Output)(nil)).(*client.Output)

		i.outputLeaveHandler(e)
	case 4:
		if i.stateHandler == nil {
			return
		}
		var e ZwlrForeignToplevelHandleV1StateEvent
		l := 0
		stateLen := int(client.Uint32(data[l : l+4]))
		l += 4
		e.State = make([]byte, stateLen)
		copy(e.State, data[l:l+stateLen])

		i.stateHandler(e)
	case 5:
		if i.doneHandler == nil {
			return
		}
		var e ZwlrForeignToplevelHandleV1DoneEvent

		i.doneHandler(e)
	case 6:
		if i.closedHandler == nil {
			return
		}
		var e ZwlrForeignToplevelHandleV1ClosedEvent

		i.closedHandler(e)
	case 7:
		if i.parentHandler == nil {
			return
		}
		var e ZwlrForeignToplevelHandleV1ParentEvent
		l := 0
		e.Parent = i.Context().GetOrRegister(client.Uint32(data[l:l+4]), (*ZwlrForeignToplevelHandleV1)(nil)).(*ZwlrForeignToplevelHandleV1)

		i.parentHandler(e)
	}
}
